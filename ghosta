local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Configurações globais
local Config = {
    Keys = {
        Mensal_1 = "Mensal_1",
        Mensal_2 = "Mensal_2",
        Mensal_3 = "Mensal_3",
        Lifetime_1 = "Lifetime_1",
        Lifetime_2 = "Lifetime_2"
    },
    URLs = {
        Ghosta = "https://raw.githubusercontent.com/LucasRj021/Script-Test/e4140912a56bc36f6c37e7d579a1cba4ce51e0b7/ghosta.lua",
        ValidationAPI = "https://your-api.com/validate"
    },
    Settings = {
        uiColor = Color3.fromRGB(30, 30, 30),
        uiAccentColor = Color3.fromRGB(0, 170, 255),
        reachValue = 100,
        uiVisible = true,
        aimbotActive = false,
        aimbotMode = "middle",
        aimbotForce = 70,
        autoGKActive = false,
        gkSensitivity = 25,
        teleportActive = false,
        autoGoalActive = false,
        espActive = false,
        fakeLag = 0.02,
        reachDynamic = true,
        reachHandMultiplier = 1.5,
        reachLegMultiplier = 1.8,
        skillRecordKey = Enum.KeyCode.F,
        autoSkillsActive = false,
        selectedConfig = nil
    }
}

-- Persistência de dados
local KeyData = {
    key = nil,
    activatedAt = nil,
    duration = 30 * 24 * 60 * 60 -- 30 dias em segundos
}

local SkillData = {
    recording = false,
    movements = {},
    lastPosition = nil,
    lastCFrame = nil,
    startTime = nil
}

local ConfigData = {
    savedConfigs = {}
}

local function saveData(file, data)
    if writefile then
        local success, err = pcall(function()
            writefile(file, HttpService:JSONEncode(data))
        end)
        if not success then warn("[Loader] Falha ao salvar dados: " .. tostring(err)) end
    end
end

local function loadData(file)
    if isfile and readfile then
        local success, data = pcall(function()
            return HttpService:JSONDecode(readfile(file))
        end)
        if success then return data end
    end
    return nil
end

-- Sistema de validação de keys melhorado
local function validateKeyOnline(key)
    local success, response = pcall(function()
        return HttpService:GetAsync(Config.URLs.ValidationAPI .. "?key=" .. HttpService:UrlEncode(key))
    end)
    if success and response then
        local data = HttpService:JSONDecode(response)
        if data.valid then
            KeyData.key = key
            KeyData.activatedAt = data.activatedAt or os.time()
            KeyData.duration = (key == Config.Keys.Lifetime_1 or key == Config.Keys.Lifetime_2) and math.huge or (data.duration or KeyData.duration)
            saveData("ghosta_key.dat", KeyData)
            print("[Loader] Key validada online com sucesso: " .. key)
            return true
        end
    end
    warn("[Loader] Falha na validação online da key: " .. key)
    return false
end

local function loadSavedKey()
    local data = loadData("ghosta_key.dat")
    if data then
        KeyData = data
        if isKeyValid() then
            print("[Loader] Key carregada do arquivo: " .. KeyData.key)
            return true
        end
    end
    return false
end

local function isKeyValid()
    if KeyData.key == Config.Keys.Lifetime_1 or KeyData.key == Config.Keys.Lifetime_2 then
        return true
    end
    if (KeyData.key == Config.Keys.Mensal_1 or KeyData.key == Config.Keys.Mensal_2 or KeyData.key == Config.Keys.Mensal_3) and KeyData.activatedAt then
        local elapsedTime = os.time() - KeyData.activatedAt
        if elapsedTime <= KeyData.duration then
            print("[Loader] Key válida, tempo restante: " .. math.floor((KeyData.duration - elapsedTime) / (24 * 60 * 60)) .. " dias")
            return true
        else
            warn("[Loader] Key expirada: " .. KeyData.key)
            KeyData.key = nil
            KeyData.activatedAt = nil
            saveData("ghosta_key.dat", KeyData)
            return false
        end
    end
    return false
end

local function activateKey(k)
    if k == Config.Keys.Lifetime_1 or k == Config.Keys.Lifetime_2 or k == Config.Keys.Mensal_1 or k == Config.Keys.Mensal_2 or k == Config.Keys.Mensal_3 then
        KeyData.key = k
        KeyData.activatedAt = os.time()
        KeyData.duration = (k == Config.Keys.Lifetime_1 or k == Config.Keys.Lifetime_2) and math.huge or KeyData.duration
        saveData("ghosta_key.dat", KeyData)
        print("[Loader] Key " .. k .. " ativada com sucesso.")
        return true
    end
    warn("[Loader] Key inválida: " .. k)
    return false
end

local function requestKey()
    if loadSavedKey() then return KeyData.key end
    print("[Loader] Insira sua Key:")
    local inputKey = io.read() or ""
    if validateKeyOnline(inputKey) or activateKey(inputKey) then
        return inputKey
    end
    warn("[Loader] Key inválida ou falha na validação. Tente novamente.")
    return nil
end

-- Download do script Ghosta
local function downloadGhosta()
    for i = 1, 5 do
        local success, response = pcall(function()
            return HttpService:GetAsync(Config.URLs.Ghosta)
        end)
        if success and response then return response end
        warn("[Loader] Tentativa " .. i .. " falhou. Retentando...")
        task.wait(1)
    end
    warn("[Loader] Falha ao baixar ghosta.lua após 5 tentativas!")
    return nil
end

local function executeGhosta(code)
    local f, err = loadstring(code)
    if not f then
        warn("[Loader] Erro no loadstring: " .. tostring(err))
        return false
    end
    local success, err2 = pcall(f)
    if not success then
        warn("[Loader] Erro ao executar ghosta.lua: " .. tostring(err2))
        return false
    end
    print("[Loader] Ghosta executado com sucesso.")
    return true
end

-- Interface do usuário
local function createUI()
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "GhostaUI"
    ScreenGui.Parent = CoreGui
    ScreenGui.IgnoreGuiInset = true

    local MainFrame = Instance.new("Frame")
    MainFrame.Size = UDim2.new(0, 400, 0, 500)
    MainFrame.Position = UDim2.new(0.5, -200, 0.5, -250)
    MainFrame.BackgroundColor3 = Config.Settings.uiColor
    MainFrame.BorderSizePixel = 0
    MainFrame.Parent = Screenocalyptic
    local Tabs = Instance.new("Frame")
    Tabs.Size = UDim2.new(1, 0, 0, 30)
    Tabs.BackgroundColor3 = Config.Settings.uiAccentColor
    Tabs.Parent = MainFrame

    local function createTab(name, position, callback)
        local TabButton = Instance.new("TextButton")
        TabButton.Size = UDim2.new(0.25, 0, 1, 0)
        TabButton.Position = UDim2.new(position, 0, 0, 0)
        TabButton.Text = name
        TabButton.BackgroundColor3 = Config.Settings.uiAccentColor
        TabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        TabButton.Parent = Tabs
        TabButton.MouseButton1Click:Connect(callback)
    end

    local TabContents = Instance.new("Frame")
    TabContents.Size = UDim2.new(1, 0, 1, -30)
    TabContents.Position = UDim2.new(0, 0, 0, 30)
    TabContents.BackgroundTransparency = 1
    TabContents.Parent = MainFrame

    local function clearTabContent()
        for _, child in pairs(TabContents:GetChildren()) do
            child:Destroy()
        end
    end

    local function createAutoSkillsTab()
        clearTabContent()
        local Content = Instance.new("Frame")
        Content.Size = UDim2.new(1, 0, 1, 0)
        Content.BackgroundTransparency = 1
        Content.Parent = TabContents

        local RecordButton = Instance.new("TextButton")
        RecordButton.Size = UDim2.new(0.45, 0, 0, 50)
        RecordButton.Position = UDim2.new(0.05, 0, 0.1, 0)
        RecordButton.Text = "Start Record Skills"
        RecordButton.BackgroundColor3 = Config.Settings.uiAccentColor
        RecordButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        RecordButton.Parent = Content
        RecordButton.MouseButton1Click:Connect(function()
            SkillData.recording = true
            SkillData.movements = {}
            SkillData.startTime = tick()
            print("[AutoSkills] Iniciando gravação de movimentos.")
        end)

        local StopButton = Instance.new("TextButton")
        StopButton.Size = UDim2.new(0.45, 0, 0, 50)
        StopButton.Position = UDim2.new(0.5, 0, 0.1, 0)
        StopButton.Text = "Stop Record Skills"
        StopButton.BackgroundColor3 = Config.Settings.uiAccentColor
        StopButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        StopButton.Parent = Content
        StopButton.MouseButton1Click:Connect(function()
            SkillData.recording = false
            print("[AutoSkills] Gravação parada. " .. #SkillData.movements .. " movimentos salvos.")
            saveData("ghosta_skills.dat", SkillData)
        end)

        local KeyLabel = Instance.new("TextLabel")
        KeyLabel.Size = UDim2.new(0.9, 0, 0, 30)
        KeyLabel.Position = UDim2.new(0.05, 0, 0.2, 0)
        KeyLabel.Text = "Skill Activation Key: " .. tostring(Config.Settings.skillRecordKey)
        KeyLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        KeyLabel.BackgroundTransparency = 1
        KeyLabel.Parent = Content

        local KeyButton = Instance.new("TextButton")
        KeyButton.Size = UDim2.new(0.9, 0, 0, 50)
        KeyButton.Position = UDim2.new(0.05, 0, 0.3, 0)
        KeyButton.Text = "Change Skill Key"
        KeyButton.BackgroundColor3 = Config.Settings.uiAccentColor
        KeyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        KeyButton.Parent = Content
        KeyButton.MouseButton1Click:Connect(function()
            KeyButton.Text = "Press a key..."
            local connection
            connection = UserInputService.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.Keyboard719
                    Config.Settings.skillRecordKey = input.KeyCode
                    KeyLabel.Text = "Skill Activation Key: " .. tostring(Config.Settings.skillRecordKey)
                    KeyButton.Text = "Change Skill Key"
                    connection:Disconnect()
                    saveData("ghosta_settings.dat", Config.Settings)
                end
            end)
        end)
    end

    local function createConfigTab()
        clearTabContent()
        local Content = Instance.new("Frame")
        Content.Size = UDim2.new(1, 0, 1, 0)
        Content.BackgroundTransparency = 1
        Content.Parent = TabContents

        local NameLabel = Instance.new("TextLabel")
        NameLabel.Size = UDim2.new(0.9, 0, 0, 30)
        NameLabel.Position = UDim2.new(0.05, 0, 0.1, 0)
        NameLabel.Text = "Config Name:"
        NameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        NameLabel.BackgroundTransparency = 1
        NameLabel.Parent = Content

        local NameInput = Instance.new("TextBox")
        NameInput.Size = UDim2.new(0.9, 0, 0, 50)
        NameInput.Position = UDim2.new(0.05, 0, 0.15, 0)
        NameInput.Text = ""
        NameInput.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        NameInput.TextColor3 = Color3.fromRGB(255, 255, 255)
        NameInput.Parent = Content

        local SaveButton = Instance.new("TextButton")
        SaveButton.Size = UDim2.new(0.45, 0, 0, 50)
        SaveButton.Position = UDim2.new(0.05, 0, 0.25, 0)
        SaveButton.Text = "Save Config"
        SaveButton.BackgroundColor3 = Config.Settings.uiAccentColor
        SaveButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        SaveButton.Parent = Content
        SaveButton.MouseButton1Click:各方面(function()
            local configName = NameInput.Text
            if configName ~= "" then
                ConfigData.savedConfigs[configName] = table.clone(Config.Settings)
                saveData("ghosta_configs.dat", ConfigData)
                print("[Config] Configuração '" .. configName .. "' salva.")
            else
            warn("[Config] Nome da configuração não pode ser vazio!")
        end)

        local DeleteButton = Instance.new("TextButton")
        DeleteButton.Size = UDim2.new(0.45, 0, 0, 50)
        DeleteButton.Position = UDim2.new(0.5, 0, 0.25, 0)
        DeleteButton.Text = "Delete Config"
        DeleteButton.BackgroundColor3 = Config.Settings.uiAccentColor
        DeleteButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        DeleteButton.Parent = Content
        DeleteButton.MouseButton1Click:Connect(function()
            local configName = NameInput.Text
            if ConfigData.savedConfigs[configName] then
                ConfigData.savedConfigs[configName] = nil
                saveData("ghosta_configs.dat", ConfigData)
                print("[Config] Configuração '" .. configName .. "' excluída.")
            else
                warn("[Config] Configuração '" .. configName .. "' não encontrada.")
            end
        end)

        local SelectButton = Instance.new("TextButton")
        SelectButton.Size = UDim2.new(0.9, 0, 0, 50)
        SelectButton.Position = UDim2.new(0.05, 0, 0.35, 0)
        SelectButton.Text = "Select Config"
        SelectButton.BackgroundColor3 = Config.Settings.uiAccentColor
        SelectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        SelectButton.Parent = Content
        SelectButton.MouseButton1Click:Connect(function()
            local configName = NameInput.Text
            if ConfigData.savedConfigs[configName] then
                Config.Settings = table.clone(ConfigData.savedConfigs[configName])
                Config.Settings.selectedConfig = configName
                saveData("ghosta_settings.dat", Config.Settings)
                print("[Config] Configuração '" .. configName .. "' selecionada.")
            else
                warn("[Config] Configuração '" .. configName .. "' não encontrada.")
            end
        end)
    end

    createTab("Auto Skills", 0, createAutoSkillsTab)
    createTab("Config", 0.75, createConfigTab)
end

-- Sistema de Auto Skills aprimorado
local function getCharacter()
    local plr = LocalPlayer
    if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Humanoid") then
        return plr.Character, plr.Character.Humanoid
    end
    return nil, nil
end

local function recordMovements()
    RunService.Heartbeat:Connect(function()
        if not SkillData.recording then return end
        local char, humanoid = getCharacter()
        if not char or not humanoid then return end
        local rootPart = char.HumanoidRootPart
        local currentTime = tick() - SkillData.startTime
        local currentPos = rootPart.Position
        local currentCFrame = rootPart.CFrame
        local inputs = {
            moveDirection = humanoid.MoveDirection,
            jump = humanoid.Jump,
            mousePos = UserInputService:GetMouseLocation(),
            keysPressed = {}
        }
        for _, input in pairs(UserInputService:GetKeysPressed()) do
            if input.UserInputType == Enum.UserInputType.Keyboard then
                table.insert(inputs.keysPressed, input.KeyCode)
            end
        end
        if SkillData.lastPosition then
            local deltaPos = (currentPos - SkillData.lastPosition).Magnitude
            if deltaPos > 0.1 or inputs.jump or #inputs.keysPressed > 0 then
                table.insert(SkillData.movements, {
                    time = currentTime,
                    position = currentPos,
                    cFrame = currentCFrame,
                    inputs = inputs
                })
            end
        end
        SkillData.lastPosition = currentPos
        SkillData.lastCFrame = currentCFrame
    end)
end

local function replayMovements()
    if not Config.Settings.autoSkillsActive then return end
    task.spawn(function()
        local startTime = tick()
        local char, humanoid = getCharacter()
        if not char or not humanoid then return end
        local rootPart = char.HumanoidRootPart
        for _, movement in ipairs(SkillData.movements) do
            while Config.Settings.autoSkillsActive and (tick() - startTime) < movement.time do
                task.wait()
            end
            if not Config.Settings.autoSkillsActive then break end
            char, humanoid = getCharacter()
            if not char or not humanoid then break end
            local tween = TweenService:Create(rootPart, TweenInfo.new(0.05, Enum.EasingStyle.Linear), {
                CFrame = movement.cFrame
            })
            tween:Play()
            humanoid:Move(movement.inputs.moveDirection)
            humanoid.Jump = movement.inputs.jump
            for _, key in pairs(movement.inputs.keysPressed) do
                game:GetService("VirtualInputManager"):SendKeyEvent(true, key, false, game)
                task.wait(0.01)
                game:GetService("VirtualInputManager"):SendKeyEvent(false, key, false, game)
            end
            local mouseDelta = movement.inputs.mousePos - UserInputService:GetMouseLocation()
            if mouseDelta.Magnitude > 5 then
                game:GetService("VirtualInputManager"):SendMouseMoveEvent(movement.inputs.mousePos.X, movement.inputs.mousePos.Y, game)
            end
        end
        Config.Settings.autoSkillsActive = false
        print("[AutoSkills] Reprodução concluída.")
    end)
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Config.Settings.skillRecordKey then
        Config.Settings.autoSkillsActive = not Config.Settings.autoSkillsActive
        if Config.Settings.autoSkillsActive then
            print("[AutoSkills] Reproduzindo movimentos salvos.")
            replayMovements()
        else
            print("[AutoSkills] Reprodução parada.")
        end
    end
end)

-- Carregar configurações salvas
local function loadSavedConfig()
    local data = loadData("ghosta_configs.dat")
    if data then
        ConfigData = data
        if Config.Settings.selectedConfig and ConfigData.savedConfigs[Config.Settings.selectedConfig] then
            Config.Settings = table.clone(ConfigData.savedConfigs[Config.Settings.selectedConfig])
            print("[Config] Configuração padrão '" .. Config.Settings.selectedConfig .. "' carregada.")
        end
    end
end

-- Funções existentes (mantidas, com pequenas otimizações)
local function advancedAnticheatBypass()
    setthreadidentity(2)
    local mt = getrawmetatable(game)
    setreadonly(mt, false)

    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        local blockedMethods = {"Kick", "Ban", "Detect", "ReportAbuse"}
        if table.find(blockedMethods, method) or method:lower():find("detect") then
            print("[Bypass] Tentativa bloqueada: " .. method)
            return nil
        end
        if method == "FireServer" and self.Name:lower():match("detect|exploit|cheat|anti") then
            print("[Bypass] Remote bloqueado: " .. self.Name)
            return nil
        end
        return oldNamecall(self, ...)
    end)

    local oldIndex
    oldIndex = hookmetamethod(game, "__index", function(self, key)
        if key:lower():match("detect|kill|ban|cheat") then
            return function(...) return true end
        end
        return oldIndex(self, key)
    end)

    local oldNewIndex = mt.__newindex
    mt.__newindex = function(t, k, v)
        if tostring(k):lower():match("velocity|position|cframe") then
            print("[Bypass] Escrita bloqueada: " .. tostring(k))
            return
        end
        return oldNewIndex(t, k, v)
    end
    setreadonly(mt, true)

    for _, conn in pairs(getconnections(game:GetService("LogService").MessageOut)) do
        conn:Disable()
    end
    for _, conn in pairs(getconnections(LocalPlayer.Chatted)) do
        conn:Disable()
    end

    for _, v in pairs(getgc(true))лом
        if type(v) == "table" and rawget(v, "Detected") then
            local oldDetect = rawget(v, "Detected")
            hookfunction(oldDetect, function(action, ...)
                if action ~= "_" then return true end
                return oldDetect(action, ...)
            end)
        end
    end

    for _, v in pairs(getgc(true)) do
        if type(v) == "function" and debug.getinfo(v).name:match("IntegrityCheck|AntiCheat") then
            hookfunction(v, function(...) return true end)
        end
    end

    local Rene = Config.Settings.fakeLag
    RunService.Heartbeat:Connect(function()
        if math.random() < 0.03 then
            task.wait(fakeLag)
        end
    end)

    local function spoofPhysics(obj)
        if obj:IsA("BasePart") then
            local oldVel = obj.Velocity
            obj.Velocity = oldVel + Vector3.new(math.random(-0.05, 0.05), math.random(-0.05, 0.05), math.random(-0.05, 0.05))
            task.wait(0.01)
            obj.Velocity = oldVel
        end
    end

    RunService.Heartbeat:Connect(function()
        local ball = detectBall()
        if ball then spoofPhysics(ball) end
    end)
end

local function detectAntcheat()
    local detected = false
    local checks = {
        function() return getrawmetatable(game) ~= nil end,
        function() return #getconnections(game:GetService("LogService").MessageOut) > 0 end,
        function() return #getconnections(LocalPlayer.Chatted) > 0 end
    }
    for _, check in ipairs(checks) do
        local success, result = pcall(check)
        if success and result then detected = true break end
    end
    return detected
end

local function ghostMode()
    warn("[Ghosta] Anticheat detectado! Ativando camuflagem avançada.")
    local char, humanoid = getCharacter()
    if humanoid then
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
        humanoid.HipHeight = 2
    end
    RunService.Heartbeat:Connect(function()
        if char and humanoid then
            local randomMove = Vector3.new(math.random(-0.5, 0.5), 0, math.random(-0.5, 0.5))
            humanoid:Move(randomMove)
        end
    end)
    local sg = CoreGui:FindFirstChildWhichIsA("ScreenGui")
    if sg then sg.Enabled = false end
    for k, v in pairs(Config.Settings) do
        if k:match("Active$") then Config.Settings[k] = false end
    end
    saveData("ghosta_settings.dat", Config.Settings)
end

-- Inicialização
local function init()
    loadSavedConfig()
    if detectAnticheat() then
        ghostMode()
    else
        advancedAnticheatBypass()
        local key = requestKey()
        if key then
            local ghostaCode = downloadGhosta()
            if ghostaCode then
                executeGhosta(ghostaCode)
            end
            createUI()
            recordMovements()
        else
            warn("[Loader] Inicialização abortada: key inválida.")
        end
    end
end

init()

 Sajie
