local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Configurações globais
local Config = {
    Keys = {
        Mensal = "Mensal_1",
        Lifetime = "Key_Lifetime"
    },
    URLs = {
        Ghosta = "https://raw.githubusercontent.com/LucasRj021/Script-Test/e4140912a56bc36f6c37e7d579a1cba4ce51e0b7/ghosta.lua",
        ValidationAPI = "https://your-api.com/validate"
    },
    Settings = {
        uiColor = Color3.fromRGB(30, 30, 30),
        uiAccentColor = Color3.fromRGB(0, 170, 255),
        reachValue = 100, -- Alcance aumentado
        uiVisible = true,
        aimbotActive = false,
        aimbotMode = "middle",
        aimbotForce = 70, -- Força ajustada
        autoGKActive = false,
        gkSensitivity = 25,
        teleportActive = false,
        autoGoalActive = false,
        espActive = false,
        fakeLag = 0.02, -- Reduzido para maior realismo
        reachDynamic = true, -- Alcance dinâmico para mãos e pernas
        reachHandMultiplier = 1.5, -- Alcance extra para mãos
        reachLegMultiplier = 1.8 -- Alcance extra para pernas
    }
}

-- Persistência de dados
local KeyData = {
    key = nil,
    activatedAt = nil,
    duration = 30 * 24 * 60 * 60 -- 30 dias em segundos
}

local function saveData(file, data)
    if writefile then
        local success, err = pcall(function()
            writefile(file, HttpService:JSONEncode(data))
        end)
        if not success then warn("[Loader] Falha ao salvar dados: " .. tostring(err)) end
    end
end

local function loadData(file)
    if isfile and readfile then
        local success, data = pcall(function()
            return HttpService:JSONDecode(readfile(file))
        end)
        if success then return data end
    end
    return nil
end

-- Sistema de validação de keys
local function validateKeyOnline(key)
    local success, response = pcall(function()
        return HttpService:GetAsync(Config.URLs.ValidationAPI .. "?key=" .. HttpService:UrlEncode(key))
    end)
    if success and response then
        local data = HttpService:JSONDecode(response)
        if data.valid then
            KeyData.key = key
            KeyData.activatedAt = data.activatedAt or os.time()
            KeyData.duration = data.duration or Config.KeyData.duration
            saveData("ghosta_key.dat", KeyData)
            print("[Loader] Key validada online com sucesso.")
            return true
        end
    end
    warn("[Loader] Falha na validação online da key.")
    return false
end

local function loadSavedKey()
    local data = loadData("ghosta_key.dat")
    if data then
        KeyData = data
        if isKeyValid() then
            print("[Loader] Key carregada do arquivo.")
            return true
        end
    end
    return false
end

local function isKeyValid()
    if KeyData.key == Config.Keys.Lifetime then return true end
    if KeyData.key == Config.Keys.Mensal and KeyData.activatedAt then
        return (os.time() - KeyData.activatedAt) <= KeyData.duration
    end
    return false
end

local function activateKey(k)
    if k == Config.Keys.Lifetime or k == Config.Keys.Mensal then
        KeyData.key = k
        KeyData.activatedAt = os.time()
        saveData("ghosta_key.dat", KeyData)
        print("[Loader] Key " .. (k == Config.Keys.Lifetime and "Lifetime" or "Mensal") .. " ativada.")
        return true
    end
    warn("[Loader] Key inválida!")
    return false
end

local function requestKey()
    if loadSavedKey() then return KeyData.key end
    print("[Loader] Insira sua Key:")
    local inputKey = io.read() or ""
    if validateKeyOnline(inputKey) or activateKey(inputKey) then
        return inputKey
    end
    return nil
end

-- Download do script Ghosta
local function downloadGhosta()
    for i = 1, 5 do
        local success, response = pcall(function()
            return HttpService:GetAsync(Config.URLs.Ghosta)
        end)
        if success and response then return response end
        warn("[Loader] Tentativa " .. i .. " falhou. Retentando...")
        task.wait(1)
    end
    warn("[Loader] Falha ao baixar ghosta.lua após 5 tentativas!")
    return nil
end

local function executeGhosta(code)
    local f, err = loadstring(code)
    if not f then
        warn("[Loader] Erro no loadstring: " .. tostring(err))
        return false
    end
    local success, err2 = pcall(f)
    if not success then
        warn("[Loader] Erro ao executar ghosta.lua: " .. tostring(err2))
        return false
    end
    print("[Loader] Ghosta executado com sucesso.")
    return true
end

-- Bypass de anticheat avançado
local function advancedAnticheatBypass()
    setthreadidentity(2)
    local mt = getrawmetatable(game)
    setreadonly(mt, false)

    -- Hook __namecall
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        local blockedMethods = {"Kick", "Ban", "Detect", "ReportAbuse"}
        if table.find(blockedMethods, method) or method:lower():find("detect") then
            print("[Bypass] Tentativa bloqueada: " .. method)
            return nil
        end
        if method == "FireServer" and self.Name:lower():match("detect|exploit|cheat|anti") then
            print("[Bypass] Remote bloqueado: " .. self.Name)
            return nil
        end
        return oldNamecall(self, ...)
    end)

    -- Hook __index
    local oldIndex
    oldIndex = hookmetamethod(game, "__index", function(self, key)
        if key:lower():match("detect|kill|ban|cheat") then
            return function(...) return true end
        end
        return oldIndex(self, key)
    end)

    -- Hook __newindex
    local oldNewIndex = mt.__newindex
    mt.__newindex = function(t, k, v)
        if tostring(k):lower():match("velocity|position|cframe") then
            print("[Bypass] Escrita bloqueada: " .. tostring(k))
            return
        end
        return oldNewIndex(t, k, v)
    end
    setreadonly(mt, true)

    -- Desativar RemoteSpy e logs
    for _, conn in pairs(getconnections(game:GetService("LogService").MessageOut)) do
        conn:Disable()
    end
    for _, conn in pairs(getconnections(LocalPlayer.Chatted)) do
        conn:Disable()
    end

    -- Bypass Adonis
    for _, v in pairs(getgc(true)) do
        if type(v) == "table" and rawget(v, "Detected") then
            local oldDetect = rawget(v, "Detected")
            hookfunction(oldDetect, function(action, ...)
                if action ~= "_" then return true end
                return oldDetect(action, ...)
            end)
        end
    end

    -- Bypass Hyperion e outros
    for _, v in pairs(getgc(true)) do
        if type(v) == "function" and debug.getinfo(v).name:match("IntegrityCheck|AntiCheat") then
            hookfunction(v, function(...) return true end)
        end
    end

    -- Simulação de comportamento humano
    local fakeLag = Config.Settings.fakeLag
    RunService.Heartbeat:Connect(function()
        if math.random() < 0.03 then
            task.wait(fakeLag)
        end
    end)

    -- Ofuscar manipulações de física
    local function spoofPhysics(obj)
        if obj:IsA("BasePart") then
            local oldVel = obj.Velocity
            obj.Velocity = oldVel + Vector3.new(math.random(-0.05, 0.05), math.random(-0.05, 0.05), math.random(-0.05, 0.05))
            task.wait(0.01)
            obj.Velocity = oldVel
        end
    end

    RunService.Heartbeat:Connect(function()
        local ball = detectBall()
        if ball then spoofPhysics(ball) end
    end)
end

local function detectAnticheat()
    local detected = false
    local checks = {
        function() return getrawmetatable(game) ~= nil end,
        function() return #getconnections(game:GetService("LogService").MessageOut) > 0 end,
        function() return #getconnections(LocalPlayer.Chatted) > 0 end
    }
    for _, check in ipairs(checks) do
        local success, result = pcall(check)
        if success and result then detected = true break end
    end
    return detected
end

-- Modo Ghosta (camuflagem)
local function ghostMode()
    warn("[Ghosta] Anticheat detectado! Ativando camuflagem avançada.")
    local char, humanoid = getCharacter()
    if humanoid then
        humanoid.WalkSpeed = 16
        humanoid.JumpPower = 50
        humanoid.HipHeight = 2
    end
    RunService.Heartbeat:Connect(function()
        if char and humanoid then
            local randomMove = Vector3.new(math.random(-0.5, 0.5), 0, math.random(-0.5, 0.5))
            humanoid:Move(randomMove)
        end
    end)
    local sg = CoreGui:FindFirstChildWhichIsA("ScreenGui")
    if sg then sg.Enabled = false end
    for k, v in pairs(Config.Settings) do
        if k:match("Active$") then Config.Settings[k] = false end
    end
    saveData("ghosta_settings.dat", Config.Settings)
end

-- Funções principais
local function getCharacter()
    local plr = LocalPlayer
    if not plr or not plr.Character then return nil end
    local c = plr.Character
    local humanoid = c:FindFirstChildOfClass("Humanoid")
    if not humanoid then return nil end
    return c, humanoid
end

local function getCharacterType(c)
    if c:FindFirstChild("RightHand") and c:FindFirstChild("LeftHand") and c:FindFirstChild("RightLowerLeg") then
        return "R15"
    elseif c:FindFirstChild("Right Arm") and c:FindFirstChild("Left Arm") then
        return "R6"
    end
    return "Unknown"
end

local function detectBall()
    local ballNames = {"ball", "soccer", "futsal", "football", "gameball", "futsalball", "soccerball"}
    local goals = {}
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name:lower():match("goal|net") then
            table.insert(goals, obj)
        end
    end
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Massless and obj.CanCollide then
            for _, name in ipairs(ballNames) do
                if obj.Name:lower():match(name) then
                    for _, goal in ipairs(goals) do
                        if (obj.Position - goal.Position).Magnitude < 120 then
                            return obj
                        end
                    end
                end
            end
        end
    end
    return nil
end

local function applyReach(amount)
    local c, humanoid = getCharacter()
    if not c then return end
    local charType = getCharacterType(c)
    local ball = detectBall()
    if not ball then return end
    local dist = (ball.Position - c.HumanoidRootPart.Position).Magnitude
    if dist < amount then
        local limbs = charType == "R15" and {"RightHand", "LeftHand", "RightLowerLeg", "LeftLowerLeg"} or {"Right Arm", "Left Arm", "Right Leg", "Left Leg"}
        for _, limbName in ipairs(limbs) do
            local limb = c:FindFirstChild(limbName)
            if limb then
                local multiplier = limbName:match("Hand|Arm") and Config.Settings.reachHandMultiplier or Config.Settings.reachLegMultiplier
                local reachDist = amount * multiplier
                local direction = (ball.Position - limb.Position).Unit
                local tween = TweenService:Create(limb, TweenInfo.new(0.05, Enum.EasingStyle.Linear), {
                    CFrame = CFrame.new(limb.Position + direction * math.min(reachDist, dist))
                })
                tween:Play()
                task.spawn(function()
                    task.wait(0.05)
                    tween:Cancel()
                    limb.CFrame = limb.CFrame -- Restaurar posição
                end)
            end
        end
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bodyVelocity.Velocity = (ball.Position - c.HumanoidRootPart.Position).Unit * 50
        bodyVelocity.Parent = ball
        game:GetService("Debris"):AddItem(bodyVelocity, 0.05)
    end
end

local function createFake(what)
    local c = getCharacter()
    if not c then return end
    local limbs = what == "arms" and {"RightHand", "LeftHand", "Right Arm", "Left Arm"} or {"RightFoot", "LeftFoot", "Right Leg", "Left Leg", "RightLowerLeg", "LeftLowerLeg"}
    for _, limbName in ipairs(limbs) do
        local limb = c:FindFirstChild(limbName)
        if limb and limb:IsA("BasePart") then
            local fake = Instance.new("Part")
            fake.Name = "Fake" .. HttpService:GenerateGUID(false)
            fake.Size = limb.Size
            fake.Position = limb.Position + Vector3.new(math.random(-0.3, 0.3), math.random(2, 4), math.random(-0.3, 0.3))
            fake.Transparency = 1
            fake.Anchored = true
            fake.CanCollide = false
            fake.Parent = c
            game:GetService("Debris"):AddItem(fake, 0.1)
        end
    end
end

local function getGoalPosition(mode)
    local goals = {}
    local enemyGK = nil
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name:lower():match("goal|net") then
            table.insert(goals, obj)
        end
    end
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChildOfClass("Tool") and player.Character:FindFirstChildOfClass("Tool").Name:lower():match("gk") then
            enemyGK = player.Character.HumanoidRootPart
        end
    end
    if #goals == 0 then return nil end
    local goal = goals[1]
    local pos = goal.Position
    local size = goal.Size
    if enemyGK then
        local gkPos = enemyGK.Position
        local gkDistRight = (gkPos - (pos + Vector3.new(size.X / 2, 0, 0))).Magnitude
        local gkDistLeft = (gkPos - (pos + Vector3.new(-size.X / 2, 0, 0))).Magnitude
        local gkDistMiddle = (gkPos - pos).Magnitude
        if mode == "right" or (gkDistRight > gkDistLeft and gkDistRight > gkDistMiddle and mode == "middle") then
            return pos + Vector3.new(size.X / 2, math.random(0, size.Y / 2), math.random(-size.Z / 4, size.Z / 4))
        elseif mode == "left" or (gkDistLeft > gkDistRight and gkDistLeft > gkDistMiddle and mode == "middle") then
            return pos + Vector3.new(-size.X / 2, math.random(0, size.Y / 2), math.random(-size.Z / 4, size.Z / 4))
        else
            return pos + Vector3.new(0, math.random(0, size.Y / 2), math.random(-size.Z / 4, size.Z / 4))
        end
    end
    if mode == "right" then
        return pos + Vector3.new(size.X / 2, math.random(0, size.Y / 2), math.random(-size.Z / 4, size.Z / 4))
    elseif mode == "left" then
        return pos + Vector3.new(-size.X / 2, math.random(0, size.Y / 2), math.random(-size.Z / 4, size.Z / 4))
    else
        return pos + Vector3.new(0, math.random(0, size.Y / 2), math.random(-size.Z / 4, size.Z / 4))
    end
end

local function aimbot()
    if not Config.Settings.aimbotActive then return end
    task.spawn(function()
        local lastUpdate = tick()
        while Config.Settings.aimbotActive do
            if tick() - lastUpdate < 0.02 then
                task.wait()
                continue
            end
            local ball = detectBall()
            if not ball then task.wait(0.05) continue end
            local goalPos = getGoalPosition(Config.Settings.aimbotMode)
            if not goalPos then task.wait(0.05) continue end
            local c, humanoid = getCharacter()
            if not c or not humanoid then task.wait(0.05) continue end

            local ray = Ray.new(ball.Position, (goalPos - ball.Position).Unit * 1000)
            local hit, pos = Workspace:FindPartOnRayWithIgnoreList(ray, {c, ball})
            if hit and not hit.Name:lower():match("goal") then
                task.wait(0.05)
                continue
            end

            local direction = (goalPos - ball.Position).Unit
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyVelocity.Velocity = direction * Config.Settings.aimbotForce
            bodyVelocity.Parent = ball
            game:GetService("Debris"):AddItem(bodyVelocity, 0.02)
            lastUpdate = tick()
            task.wait(0.02)
        end
    end)
end

local function autoGK()
    if not Config.Settings.autoGKActive then return end
    task.spawn(function()
        local lastUpdate = tick()
        local lastPos, lastVel
        while Config.Settings.autoGKActive do
            if tick() - lastUpdate < 0.02 then
                task.wait()
                continue
            end
            local c, humanoid = getCharacter()
            if not c or not humanoid then task.wait(0.05) continue end
            local tool = c:FindFirstChildOfClass("Tool")
            if not tool or not tool.Name:lower():match("gk") then task.wait(0.05) continue end

            local ball = detectBall()
            if not ball then task.wait(0.05) continue end

            local ballPos = ball.Position
            local ballVel = ball.Velocity
            if lastPos and lastVel then
                local delta = tick() - lastUpdate
                local accel = (ballVel - lastVel) / delta
                local predictedPos = ballPos + ballVel * 0.06 + 0.5 * accel * (0.06 ^ 2)
                local charPos = c.HumanoidRootPart.Position
                local dist = (predictedPos - charPos).Magnitude
                if dist < Config.Settings.gkSensitivity then
                    humanoid.Jump = true
                    local moveDir = (predictedPos - charPos).Unit
                    local tween = TweenService:Create(c.HumanoidRootPart, TweenInfo.new(0.08, Enum.EasingStyle.Linear), {
                        CFrame = CFrame.new(charPos + moveDir * math.min(16 * delta, dist))
                    })
                    tween:Play()
                end
            end
            lastPos = ballPos
            lastVel = ballVel
            lastUpdate = tick()
            task.wait(0.02)
        end
    end)
end

local function teleportBall()
    if not Config.Settings.teleportActive then return end
    task.spawn(function()
        local c, humanoid = getCharacter()
        if not c or not humanoid then return end
        local ball = detectBall()
        if not ball then return end
        local charPos = c.HumanoidRootPart.Position
        local tween = TweenService:Create(ball, TweenInfo.new(0.08, Enum.EasingStyle.Linear), {
            CFrame = CFrame.new(charPos + Vector3.new(2, 0, 0))
        })
        tween:Play()
    end)
end

local function autoGoal()
    if not Config.Settings.autoGoalActive then return end
    task.spawn(function()
        local lastUpdate = tick()
        while Config.Settings.autoGoalActive do
            if tick() - lastUpdate < 0.08 then
                task.wait()
                continue
            end
            local c, humanoid = getCharacter()
            if not c or not humanoid then task.wait(0.05
